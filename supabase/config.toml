import dotenv from 'dotenv';
dotenv.config();

import express from 'express';
import cors from 'cors';
import multer from 'multer';
import AWS from 'aws-sdk';
import axios from 'axios';
import sharp from 'sharp';

import { enqueueJob } from './services/jobs.js';
import { supabase } from './supabaseClient.js';
import { enqueueManualReview } from './services/manualReviews.js';
import { docTypes as docTypesRegistry } from './docTypes.js';

import validatePassport from './utils/validatePassport.js';
import validateMRZ from './utils/validateMRZ.js';
import validateDOB from './utils/validateDOB.js';
import validateNTUCard from './utils/validateNTUCard.js';
import matchNames from './utils/matchNames.js';

const app = express();
app.use(cors());
app.use(express.json());

const OCR_BASE = process.env.GOOGLE_VISION_ENDPOINT;
const OCR_KEY = process.env.GOOGLE_VISION_API_KEY;

const upload = multer({
    storage: multer.memoryStorage(),
    limits: { fileSize: 10 * 1024 * 1024 }, // 10 MB max
});

AWS.config.update({
    region: 'eu-west-2',
    accessKeyId: process.env.AWS_ACCESS_KEY_ID,
    secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY,
});
const rekognition = new AWS.Rekognition();
const GOOGLE_VISION_ENDPOINT = process.env.GOOGLE_VISION_ENDPOINT;

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// HEALTH CHECK
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
app.get('/', (req, res) => {
    res.send('âœ… PreLink Verification Server is alive');
});

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// MAIN VERIFICATION ENDPOINT
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
app.post(
    '/compare-faces',
    upload.fields([
        { name: 'selfie', maxCount: 1 },
        { name: 'idCard', maxCount: 1 },
        { name: 'ntuCardFront', maxCount: 1 },
        { name: 'provisionalLicence', maxCount: 1 },
        { name: 'drivingLicence', maxCount: 1 },
    ]),
    async (req, res) => {
        const { selfie, idCard, ntuCardFront } = req.files;
        let { uid } = req.body;
        if (!uid) uid = 'test-user';
        if (!selfie || !idCard || !ntuCardFront) {
            return res
                .status(400)
                .json({ error: 'Missing one of: selfie, idCard or ntuCardFront.' });
        }

        let job;
        try {
            job = await enqueueJob(uid);
            console.log('ðŸ—’ï¸  Job enqueued:', job);
        } catch (err) {
            console.error('âŒ enqueueJob error:', err);
            return res.status(500).json({
                success: false,
                retryable: true,
                code: 'JOB_QUEUE_FAILED',
                message: 'Could not start verification. Please try again shortly.',
            });
        }
        console.log(`ðŸš€ Verification request received (job_id=${job.job_id}) for UID:`, uid);

        // â€¦ earlier in your handler, before the try block:
        let fullText = '';
        let mrzText = '';

        try {
            const GOOGLE_VISION_BASE = process.env.GOOGLE_VISION_BASE?.trim();
            const GOOGLE_VISION_API_KEY = process.env.GOOGLE_VISION_API_KEY?.trim();

            if (!GOOGLE_VISION_BASE || !GOOGLE_VISION_API_KEY) {
                console.error('âš ï¸ OCR config missing:', { GOOGLE_VISION_BASE, GOOGLE_VISION_API_KEY });
                return res.status(500).json({
                    success: false,
                    retryable: false,
                    code: 'OCR_CONFIG_ERROR',
                    message: 'Google Vision API not configured properly.'
                });
            }

            const GOOGLE_VISION_ENDPOINT = `${GOOGLE_VISION_BASE}?key=${encodeURIComponent(GOOGLE_VISION_API_KEY)}`;
            console.log('ðŸ“¡ OCR endpoint â†’', GOOGLE_VISION_ENDPOINT);

            // 1ï¸âƒ£ Prepare full-page + MRZ buffers
            const rawBuf = idCard[0].buffer;

            // â”€ Preprocess: auto-rotate, grayscale, normalize, sharpen â”€
            const prepped = await sharp(rawBuf)
                .rotate()
                .grayscale()
                .normalize()
                .sharpen()
                .toBuffer();

            const png = await sharp(prepped)
                .toFormat('png')
                .threshold(128)
                .toBuffer();

            const dithered = await sharp(png)
                .modulate({ brightness: 1.1 })
                .toColourspace('b-w')
                .png({ quality: 100, palette: true, dither: 1.0 })
                .toBuffer();

            // â”€ Binarize & denoise â”€
            const binarized = await sharp(prepped)
                .threshold(150)
                .toBuffer();

            const denoised = await sharp(binarized)
                .median(1)
                .toBuffer();

            // â”€ Resize for OCR clarity â”€
            const resized = await sharp(denoised)
                .resize({ width: 1600, withoutEnlargement: true })
                .toBuffer();

            const fullPageBuf = resized;
            const { width, height } = await sharp(fullPageBuf).metadata();

            // â”€ Compute and clamp MRZ crop region â”€
            // Grab the bottom 30% of the card (max 350px tall)
            let mrzHeight = Math.min(Math.floor(height * 0.30), 350);
            // Start the crop so it ends exactly at the bottom of the image
            let yStart = Math.max(0, height - mrzHeight);
            // Keep 5% horizontal margins
            let xMargin = Math.floor(width * 0.05);

            // Clamp to valid ranges
            yStart = Math.max(0, yStart);
            mrzHeight = Math.min(mrzHeight, height - yStart);
            xMargin = Math.max(0, Math.min(xMargin, Math.floor(width / 3)));

            const cropWidth = width - xMargin * 2;
            const cropHeight = mrzHeight;
            const top = yStart;
            const left = xMargin;

            console.log(
                `ðŸ” MRZ crop â†’ top:${top}px height:${cropHeight}px ` +
                `left:${left}px width:${cropWidth}px`
            );

            // final safety clamp
            const safeHeight = Math.min(cropHeight, height - top);
            const safeWidth = Math.min(cropWidth, width - left);

            // â”€â”€â”€ Perform the safe MRZ extract (with fallback) â”€â”€â”€
            let mrzCropBuf;
            try {
                mrzCropBuf = await sharp(fullPageBuf)
                    .extract({ left, top, width: safeWidth, height: safeHeight })
                    .grayscale()
                    .normalize()
                    .sharpen()
                    .toBuffer();
            } catch (cropErr) {
                console.warn('âš ï¸ MRZ crop failed, falling back to full-page OCR:', cropErr);
                mrzCropBuf = fullPageBuf;
            }

            // 2ï¸âƒ£ Build two OCR requests
            const buildRequest = (buf) => ({
                requests: [{
                    image: { content: buf.toString('base64') },
                    features: [{ type: 'DOCUMENT_TEXT_DETECTION' }],
                    imageContext: { languageHints: ['en', 'fr'] }
                }]
            });
            const fullPageReq = buildRequest(fullPageBuf);
            const mrzReq = buildRequest(mrzCropBuf);

            // 3ï¸âƒ£ Fire both in parallel
            const [fullPageRes, mrzRes] = await Promise.all([
                axios.post(GOOGLE_VISION_ENDPOINT, fullPageReq, { headers: { 'Content-Type': 'application/json' }, timeout: 60000 }),
                axios.post(GOOGLE_VISION_ENDPOINT, mrzReq, { headers: { 'Content-Type': 'application/json' }, timeout: 60000 })
            ]);

            // 4ï¸âƒ£ Extract text, with fallback
            fullText = fullPageRes.data.responses?.[0]?.fullTextAnnotation?.text
                || fullPageRes.data.responses?.[0]?.textAnnotations?.[0]?.description
                || '';
            mrzText = mrzRes.data.responses?.[0]?.fullTextAnnotation?.text
                || mrzRes.data.responses?.[0]?.textAnnotations?.[0]?.description
                || '';

            // 5ï¸âƒ£ If MRZ didnâ€™t yield two lines, pull them heuristically from full-page annotations
            if (!mrzText.includes('\n')) {
                const rawLines = (fullPageRes.data.responses[0].textAnnotations || [])
                    .slice(1)
                    .map(t => t.description)
                    .filter(t => /^[A-Z0-9<]{10,}$/.test(t));

                if (rawLines.length >= 2) {
                    mrzText = rawLines.join('\n').slice(-88);
                }
            }

            console.log('ðŸ” [OCR full-page] â†’', fullText.slice(0, 200));
            console.log('ðŸ” [OCR MRZ strip] â†’', mrzText);


        } catch (ocrErr) {
            console.error('âŒ MRZ cropping/OCR error:', ocrErr);
            return res.status(500).json({
                success: false,
                retryable: false,
                code: 'MRZ_CROP_FAILED',
                message: ocrErr.message
            });
        }

        // Now fullText and mrzText are both defined

        const compareFaces = async (src, tgt) => {
            const result = await rekognition
                .compareFaces({
                    SourceImage: { Bytes: src },
                    TargetImage: { Bytes: tgt },
                    SimilarityThreshold: 95,
                })
                .promise();
            return result.FaceMatches?.[0]?.Similarity || 0;
        };

        const selfieBuf = selfie[0].buffer;
        const idBuf = idCard[0].buffer;
        const ntuBuf = ntuCardFront[0].buffer;

        const simSelfieID = await compareFaces(selfieBuf, idBuf);
        const simSelfieNTU = await compareFaces(selfieBuf, ntuBuf);
        const simIDNTU = await compareFaces(idBuf, ntuBuf);
        const matchSelfieID = simSelfieID >= 95;
        const matchSelfieNTU = simSelfieNTU >= 95;
        const matchIDNTU = simIDNTU >= 95;
        const overallFaceMatch = matchSelfieID && matchSelfieNTU && matchIDNTU;

        console.log('ðŸ§  Face Match Results:', {
            simSelfieID,
            simSelfieNTU,
            simIDNTU,
            matchSelfieID,
            matchSelfieNTU,
            matchIDNTU,
        });


        const passportResult = validatePassport(fullText, mrzText);
        console.log({ passportResult });
        const mrzResult = (() => {
            try {
                return validateMRZ(mrzText);
            } catch {
                return { valid: false, name: null, dob: null };
            }
        })();
        console.log({ mrzResult });
        const dobResult = validateDOB(fullText);
        console.log('ðŸ“‹ DOB Result:', dobResult);
        const ntuResult = await validateNTUCard(ntuBuf);

        console.log('âœ… Utility results:', {
            passportResult,
            mrzResult,
            dobResult,
            ntuResult,
        });

        const extractedName = passportResult.name || mrzResult.name;
        const extractedDOB = passportResult.dob || mrzResult.dob || dobResult.dob;
        const ntuName = ntuResult.name;
        const ntuMatch = extractedName && ntuName
            ? matchNames(ntuName, extractedName)
            : false;

        try {
            const insertResp = await supabase
                .from('verifications')
                .insert([{
                    uid,
                    job_id: job.job_id,
                    status:
                        overallFaceMatch &&
                            ntuMatch &&
                            passportResult.valid &&
                            ntuResult.valid
                            ? 'success'
                            : 'no_match',
                    similarity: Math.min(simSelfieID, simSelfieNTU, simIDNTU),
                    name: extractedName,
                    dob: extractedDOB,
                    ntuName,
                    ntuMatch,
                    method: 'rekogn+ocr',
                    timestamp: new Date().toISOString(),
                    raw_ocr: fullText,             // the full-page OCR text
                    field_confidence: {            // per-field confidences, if available
                        passport: passportResult.confidence,
                        mrz: mrzResult.confidence,
                        dob: dobResult.confidence,
                        ntu: ntuResult.confidence
                    }
                },
                ])
                .select('id');

            // 1) Check for Supabase error
            if (insertResp.error) {
                throw insertResp.error;
            }
            // 2) Ensure at least one row was returned
            if (!insertResp.data || insertResp.data.length === 0) {
                throw new Error('Supabase returned no rows on insert');
            }

            // 3) Grab the inserted record
            const verification = insertResp.data[0];
            console.log('ðŸ“¥ Logged to Supabase, id=', verification.id);

            // Respond to client
            res.json({
                success:
                    overallFaceMatch &&
                    ntuMatch &&
                    passportResult.valid &&
                    ntuResult.valid,
                matches: {
                    selfieToID: matchSelfieID,
                    selfieToNTU: matchSelfieNTU,
                    idToNTU: matchIDNTU,
                    ntuToPassport: ntuMatch,
                },
                similarities: {
                    selfieToID: simSelfieID,
                    selfieToNTU: simSelfieNTU,
                    idToNTU: simIDNTU,
                },
                extracted: {
                    passportName: extractedName,
                    dob: extractedDOB,
                    ntuName,
                },
                utils: {
                    passportResult,
                    mrzResult,
                    dobResult,
                    ninoResult,
                    ntuResult,
                },
                verificationId: verification.id,
            });
        } catch (err) {
            console.error('âŒ Persist error:', err.message);
            // Optionally log failed verification row for diagnostics
            await supabase.from('verifications').insert([{
                uid,
                status: 'failed',
                error: err.message,
                method: 'rekogn+ocr',
                timestamp: new Date().toISOString(),
            }]);
            return res.status(500).json({ success: false, error: err.message });
        }

    }
);

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// PRESIGNED UPLOAD ENDPOINT
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
app.get('/upload-url/:filename', async (req, res) => {
    const { filename } = req.params;
    const bucket = process.env.SUPABASE_BUCKET;
    const filePath = `uploads/${filename}`;
    const { data, error } = await supabase.storage
        .from(bucket)
        .createSignedUploadUrl(filePath, 60);
    if (error) return res.status(500).json({ success: false, error: error.message });
    const { publicURL } = supabase.storage.from(bucket).getPublicUrl(filePath);
    res.json({ success: true, signedURL: data.signedURL, publicURL });
});

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// HEALTHCHECK ENDPOINT
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
app.get('/health', (_, res) =>
    res.status(200).json({ status: 'ok', uptime: process.uptime() })
);

// âœ… 16. CENTRAL ERROR HANDLER
app.use((err, req, res, next) => {
    console.error('ðŸ›‘ Uncaught error:', err);
    res.status(500).json({ success: false, message: err.message });
});

const PORT = process.env.PORT || 10000;
app.listen(PORT, () =>
    console.log(`ðŸš€ PreLink server running on port ${PORT}`)
);
